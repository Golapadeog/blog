[{"content":"Une des façons les plus simples et courantes d\u0026rsquo;utiliser les services de messagerie tels qu\u0026rsquo;Azure Service Bus est pour effectuer une communication unidirectionnel.\nsource:\rhttps://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-overview\r\r\nExemple: Bob en tant qu\u0026rsquo;envoyeur de message et Eve en tant que réceptionniste.\n1. Eve écoute la file d\u0026rsquo;attente Q1\n2. Bob envoie un message sur Q1\n3. Eve reçoit le message de Bob à partir Q1\nMais comment Bob peut-il savoir que le traitement de Eve est terminé ?\nOu plus généralement comment ces 2 services peuvent-ils communiquer de manière bidirectionnelle? C\u0026rsquo;est là que le pattern Request/Response (ou Request/Reply) intervient. Ce pattern utilise un routage de message afin d\u0026rsquo;obtenir une communication bidirectionnel entre deux services.\nFonctionnellement c\u0026rsquo;est très simple, l\u0026rsquo;envoyeur envoie un message sur une file d\u0026rsquo;attente et attend une réponse sur une autre file d\u0026rsquo;attente.\nsource:\rhttps://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReplyJmsExample.html\r\r\nIl existe 4 types de routage principaux qui sont très bien détaillés ici : https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messages-payloads\nDans la version \u0026ldquo;la plus simple\u0026rdquo; (Request/Response simple), il n\u0026rsquo;existe aucune garantie que Bob reçoit son message de réponse. En effet si un nouvel utilisateur nommé Alice écoute la même file d\u0026rsquo;attente, elle pourrait intercepter le message destiné à Bob.\nConcurrence entre Bob et Alice:\r\r\nRequest/Response multiplexé Pour garantir que Bob soit le seul à récupérer le message de réponse qui lui est destiné, nous allons utiliser les sessions.\nBob écoute et verrouille une session spécifique sur la file d\u0026rsquo;attente, ainsi lui seul pourra écouter ses messages (à l\u0026rsquo;image d\u0026rsquo;une sous file d\u0026rsquo;attente réservée à Bob).\nBob devra fournir des informations supplémentaires à son message afin que le réceptionneur (Eve) puisse envoyer correctement le message de réponse.\nTechniquement cela se traduit par deux propriétés :\n ReplyTo: chemin d\u0026rsquo;accès où Bob attend la réponse. Eve y enverra son message de réponse. ReplyToSessionId: l\u0026rsquo;id de la session écoutée par Bob. Eve assignera cette valeur à la propriété SessionId de son message de réponse.  Exemple L\u0026rsquo;exemple sera réalisé avec Microsoft.Azure.ServiceBus et de deux file d\u0026rsquo;attente (la logique reste la même avec les rubriques).\nTechniquement il est indispensable que la file d\u0026rsquo;attente de réponse accepte les sessions.\nCela peut se fait via le portail Azure.\nsource:\rhttps://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions\r\r\nOu via le code avec la propriété RequiresSession.\nCreation des files d\u0026rsquo;attente Dans un premier temps nous allons créer pour la démonstration 2 files d\u0026rsquo;attente:\n sample.request: sans session, utilisé pour envoyer les messages de Bob à traiter par Eve. sample.retry: avec session, utilisé pour envoyer la réponse à Bob.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  static async Task Main()\r{\rvar connectionString = \u0026#34;\u0026lt;your_connection_string\u0026gt;\u0026#34;;\rvar requestQueueName = \u0026#34;sample.request\u0026#34;;\rvar replyQueueName = \u0026#34;sample.reply\u0026#34;;\r// create queues\r await Task.WhenAll(CreateQueueAsync(connectionString, requestQueueName, false), CreateQueueAsync(connectionString, replyQueueName, true));\r}\rstatic async Task CreateQueueAsync(string connectionString, string queueName, bool requiresSession)\r{\rvar managementClient = new ManagementClient(connectionString);\r//it\u0026#39;s just for the demo\r if (await managementClient.QueueExistsAsync(queueName))\r{\rawait managementClient.DeleteQueueAsync(queueName);\r}\rawait managementClient.CreateQueueAsync(new QueueDescription(queueName)\r{\rRequiresSession = requiresSession\r});\r}\r  Pour la démonstration chaque service sera simulé par un thread.\nThread de l\u0026rsquo;envoyeur (Bob) Bob envoie un message avec la propriété ReplyTo égal au chemin d\u0026rsquo;accès à la file d\u0026rsquo;attente de réponse et ReplyToSessionId égal à l\u0026rsquo;identifiant sa session.\nUne fois le message envoyé Bob écoute sa session.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public static class SampleThreadFactory\r{\r...\rpublic static Thread CreateRequestor(string threadId, string connectionString, string requestQueueName, string replyQueueName)\r{\rreturn new Thread(async () =\u0026gt;\r{\rvar messageSender = new MessageSender(connectionString, requestQueueName);\rvar sessionId = Guid.NewGuid().ToString();\rvar message = new Message\r{\rMessageId = threadId,\rReplyTo = new ServiceBusConnectionStringBuilder(connectionString) { EntityPath = replyQueueName }.ToString(),\rReplyToSessionId = sessionId,\rTimeToLive = TimeSpan.FromMinutes(2)\r};\rConsole.WriteLine($\u0026#34;{threadId} send a message to \u0026#39;{requestQueueName}\u0026#39; with replyToSessionId=\u0026#39;{message.ReplyToSessionId}\u0026#39; and entityPath=\u0026#39;{replyQueueName}\u0026#39;\\n\u0026#34;);\rawait messageSender.SendAsync(message);\rSessionClient sessionClient = new SessionClient(connectionString, replyQueueName);\rvar session = await sessionClient.AcceptMessageSessionAsync(sessionId);\rConsole.WriteLine($\u0026#34;{threadId}\u0026#39;s waiting a reply message from \u0026#39;{replyQueueName}\u0026#39; with sessionId=\u0026#39;{sessionId}\u0026#39;...\\n\u0026#34;);\rMessage sessionMessage = await session.ReceiveAsync();\rConsole.WriteLine($\u0026#34;{threadId} received a reply message from \u0026#39;{replyQueueName}\u0026#39; with sessionId=\u0026#39;{sessionMessage.SessionId} (original: {sessionId})\u0026#39;\\n\u0026#34;);\r});\r}\r}\r  Thread du répondeur (Eve) Eve écoute la file d\u0026rsquo;attente sur laquelle Bob envoie ses messages.\nUne fois qu\u0026rsquo;un message est intercepté, elle envoie un message de réponse sur le chemin d\u0026rsquo;accès défini par la propriété ReplyTo.\nLe message envoyé contient la propriété SessionId définie à partir la propriété ReplyToSessionId du message intercepté (et pour le suivi ainsi qu\u0026rsquo;une standardisation, il est fortement recommandé de définir la propriété CorrelationId avec l\u0026rsquo;id du message réceptionné).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public static class SampleThreadFactory\r{\rpublic static Thread CreateReplier(string threadId, string connectionString, string requestQueueName)\r{\rreturn new Thread(() =\u0026gt;\r{\rvar messageReceiver = new MessageReceiver(connectionString, requestQueueName);\rmessageReceiver.RegisterMessageHandler(\rasync (message, cancellationToken) =\u0026gt;\r{\rvar connectionStringBuilder = new ServiceBusConnectionStringBuilder(message.ReplyTo);\rvar replyToQueue = new MessageSender(connectionStringBuilder);\rvar replyMessage = new Message(Encoding.UTF8.GetBytes($\u0026#34;processed by {threadId}\u0026#34;))\r{\rCorrelationId = message.MessageId,\rSessionId = message.ReplyToSessionId,\rTimeToLive = TimeSpan.FromMinutes(2)\r};\r/**** Simulate an action *****/\rConsole.WriteLine($\u0026#34;{threadId} works...\\n\u0026#34;);\rawait Task.Delay(new Random().Next(1000, 2000), cancellationToken);\r/*******************************/\rConsole.WriteLine($\u0026#34;{threadId} send a reply message to \u0026#39;{connectionStringBuilder.EntityPath}\u0026#39; with sessionId=\u0026#39;{message.ReplyToSessionId}\u0026#39;\\n\u0026#34;);\rawait replyToQueue.SendAsync(replyMessage);\r}, new MessageHandlerOptions(args =\u0026gt; throw args.Exception)\r{\rMaxConcurrentCalls = 10\r});\r});\r}\r  Initialisation du contexte de test 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  static async Task Main()\r{\rvar connectionString = \u0026#34;\u0026lt;your_connection_string\u0026gt;\u0026#34;;\rvar requestQueueName = \u0026#34;sample.request\u0026#34;;\rvar replyQueueName = \u0026#34;sample.reply\u0026#34;;\r// create queues\r await Task.WhenAll(CreateQueueAsync(connectionString, requestQueueName, false), CreateQueueAsync(connectionString, replyQueueName, true));\r// start all\r Parallel.ForEach(new List\u0026lt;Thread\u0026gt;\r{\rSampleThreadFactory.CreateRequestor(\u0026#34;REQUESTOR-BOB\u0026#34;, connectionString, requestQueueName, replyQueueName),\rSampleThreadFactory.CreateReplier(\u0026#34;REPLIER-EVE\u0026#34;, connectionString, requestQueueName)\r}, (thread, state) =\u0026gt; thread.Start());\rConsole.Read();\r}\r  Résulat Et aucun problème avec plusieurs envoyeur, chacun reçoit le message de réponse qui lui est destiné.\nVoilà!\nSources Repository:  https://github.com/Golapadeog/sample-azure-service-bus-request-response  Documentation:  https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReplyJmsExample.html https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-amqp-request-response https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messages-payloads https://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions https://en.wikipedia.org/wiki/Request%E2%80%93response  ","description":"","id":7,"section":"posts","tags":["azure","pattern"],"title":"[Azure] Pattern Request/Response avec Azure Service Bus","uri":"https://golapadeog.github.io/blog/fr/2020/03/22/azure-pattern-request/response-avec-azure-service-bus/"},{"content":"Lors d\u0026rsquo;une tentative d\u0026rsquo;un copier/coller (pression longue) sur un champ Text sur IOS le message suivant peut apparaitre :\n The getter \u0026lsquo;pasteButtonLabel\u0026rsquo; was called on null.\nReceiver: null\nTried calling: pasteButtonLabel\r Si tel est le cas, c\u0026rsquo;est qu\u0026rsquo;IOS n\u0026rsquo;arrive tout simplement pas à trouver la localisation adaptée pour les boutons d\u0026rsquo;actions.\nPour corriger ce point il suffit de créer un LocalizationsDelegate personnalisé pour IOS :\n1 2 3 4 5 6 7 8 9 10 11 12  class CupertinoLocalisationsDelegate extends LocalizationsDelegate\u0026lt;CupertinoLocalizations\u0026gt; {\rconst CupertinoLocalisationsDelegate();\r@override\rbool isSupported(Locale locale) =\u0026gt; true;\r@override\rFuture\u0026lt;CupertinoLocalizations\u0026gt; load(Locale locale) =\u0026gt; DefaultCupertinoLocalizations.load(locale);\r@override\rbool shouldReload(CupertinoLocalisationsDelegateold) =\u0026gt; false;\r}\r  Et de l\u0026rsquo;utiliser au niveau de la MaterialApp :\n1 2 3 4 5 6 7  MaterialApp(\r...\rlocalizationsDelegates: const \u0026lt;LocalizationsDelegate\u0026lt;dynamic\u0026gt;\u0026gt;[\rGlobalMaterialLocalizations.delegate,\rGlobalWidgetsLocalizations.delegate,\r+ CupertinoLocalisationsDelegate(),\r ], ...\r  A noter qu\u0026rsquo;avec cette classe la localisation utilisée pour les actions sera celle par défaut du téléphone.\nPour corriger ce point il faut modifier la logique de la méthode load(Local locale) qui permet de définir la localisation.\r ","description":"Exception : The getter \"pasteButtonLabel\" was called on null","id":8,"section":"posts","tags":["flutter","dart","ios","mobile","exception"],"title":"[Flutter] Exception lors d'une copie sous IOS","uri":"https://golapadeog.github.io/blog/fr/2019/10/21/flutter-exception-lors-dune-copie-sous-ios/"}]