[{"content":"Le traitement d\u0026rsquo;un fichier csv de plusieurs Go peut vite être coûteux en terme de performance.\nPour rappel un fichier csv n\u0026rsquo;est pas seulement un format qui sépare ses colonnes par un caractère, mais c\u0026rsquo;est aussi:\n des entêtes présentes ou non, des colonnes parfois inexistantes, des lignes vides, des guillemets pour représenter une colonne, des guillemets dans des guillemets pour représenter des guillemets dans une colonnes… …  Bref, la liste est encore longue et ça peut vite devenir un vrai casse tête de gérer tous les cas.\nA cela s\u0026rsquo;ajoute qu\u0026rsquo;il faut la plupart du temps lier les colonnes à des objets de notre code et que dans le cas d\u0026rsquo;un très gros fichier il n\u0026rsquo;est pas envisageable de charger le fichier en mémoire et qu\u0026rsquo;il faudra lire à même le stream ce qui peut apporter d\u0026rsquo;autres problématiques (heureusement en .NET cette dernière problématique reste extrêmement simple à solutionner).\nBien entendu d\u0026rsquo;autres se sont pris la tête là-dessus, c\u0026rsquo;est pour cette raison qu\u0026rsquo;il existe un grand nombre de framework de lecture/écriture de fichier csv qui gère la totalité des problématique liées à ce format.\nTextFieldParser Peu connue, mais le framework .NET propose une solution de base avec TextFieldParser.\nSampleCsvParser\rFoo\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  [Benchmark]\rpublic void TextFieldParser()\r{\rusing var streamReader = new StreamReader(_csvFilePath);\rTextFieldParser parser = new TextFieldParser(_csvFilePath)\r{\rHasFieldsEnclosedInQuotes = true,\rDelimiters = new[] { \u0026#34;,\u0026#34; }\r};\rstring[] fields;\rwhile ((fields = parser.ReadFields()) != null)\r{\rFoo.CreateFromFields(fields);\r// ...\r }\r}\r  \r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class Foo\r{\rpublic string Prop0 { get; set; }\rpublic string Prop1 { get; set; }\rpublic string Prop2 { get; set; }\rpublic static Foo CreateFromFields(string[] fields)\r{\rreturn new Foo\r{\rProp0 = fields[0],\rProp1 = fields[1],\rProp2 = fields[2],\r};\r}\r}\r  \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"58cc5360c576fa3c\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r CsvHelper sources: https://github.com/JoshClose/CsvHelper\nSampleCsvParser\rFooMapping\r\r1 2 3 4 5 6 7 8 9 10 11 12 13  [Benchmark]\rpublic void CsvHelper()\r{\rusing var streamReader = new StreamReader(_csvFilePath);\rvar csvconfig = new CsvConfiguration(CultureInfo.CurrentCulture) { Delimiter = \u0026#34;,\u0026#34;, HasHeaderRecord = false };\rcsvconfig.RegisterClassMap\u0026lt;CsvHelperFooMapping\u0026gt;();\rvar csv = new CsvReader(streamReader, csvconfig);\rusing var records = csv.GetRecords\u0026lt;Foo\u0026gt;().GetEnumerator();\rwhile (records.MoveNext())\r{\r// ...\r }\r}\r  \r\r1 2 3 4 5 6 7 8 9  public sealed class CsvHelperFooMapping: ClassMap\u0026lt;Foo\u0026gt;\r{\rpublic CsvHelperFooMapping()\r{\rMap(x =\u0026gt; x.Prop0).Index(0);\rMap(x =\u0026gt; x.Prop1).Index(1);\rMap(x =\u0026gt; x.Prop2).Index(2);\r}\r}\r  \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"f29cba5f58fc2b46\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r TinyCsvParser sources: https://github.com/bytefish/TinyCsvParser\nSampleCsvParser\rFooMapping\r\r1 2 3 4 5 6 7 8 9 10 11  public void TinyCsvParser()\r{\rvar csvParserOptions = new CsvParserOptions(false, \u0026#39;,\u0026#39;, Environment.ProcessorCount, false);\rvar csvMapper = new TinyFooMapping();\rvar csvParser = new CsvParser\u0026lt;Foo\u0026gt;(csvParserOptions, csvMapper);\rusing var records = csvParser.ReadFromFile(_csvFilePath, Encoding.UTF8).GetEnumerator();\rwhile (records.MoveNext())\r{\r// ...\r }\r}\r  \r\r1 2 3 4 5 6 7 8 9  public sealed class TinyFooMapping : CsvMapping\u0026lt;Foo\u0026gt;\r{\rpublic TinyFooMapping()\r{\rMapProperty(0, x =\u0026gt; x.Prop0);\rMapProperty(1, x =\u0026gt; x.Prop1);\rMapProperty(2, x =\u0026gt; x.Prop2);\r}\r}\r  \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"0d2480d40565aeb6\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r Résultat (100 000 lignes + ssd)    Method Mean %     TextFieldParser 6,617.43 ms 0%   CsvHelper 4,018.37 ms -39 %   TinyCsvParser 1,062.29 ms -84 %    Doit-on d\u0026rsquo;office exclure CsvHelper?\nNon, comme toujours en développement rien n\u0026rsquo;est blanc ou noir.\nDans ce cas spécifique (un csv propre, une configuration de base et une lecture d\u0026rsquo;un gros fichier) TinyCsvParser est préférable en revanche dans d\u0026rsquo;autres scénarii CsvHelper apporte des fonctionnalités très intéressantes (comme l\u0026rsquo;auto-mapping) qui peuvent faire gagner un précieux temps de développement et de maintenance.\nBref cela dépend de la situation comme toujours.\nMais comment expliquer de tels décalages ? Principalement cela est dû au traitement des lignes du CSV pour gérer tous les cas et la création des entités.\nNous avons tendance à se ruer sur des framework pour des choses simples, c\u0026rsquo;est framework sont là pour gérer tous les cas ce qui apporte un confort de développement mais aussi une lourdeur dans les traitements.\nJ\u0026rsquo;ai récemment dû parser un fichier de 30Go \u0026ldquo;propre\u0026rdquo; (virgule + parfois des guillemet) dont je connais parfaitement le format, et j\u0026rsquo;ai voulu voir combien coûte \u0026ldquo;la gestion de tous les cas\u0026rdquo;.\nSolution personnalisée SampleCsvParser\rFoo\r\r1 2 3 4 5 6 7 8 9 10 11  [Benchmark]\rpublic void Custom()\r{\rusing var streamReader = new StreamReader(_csvFilePath);\rstring line;\rwhile ((line = streamReader.ReadLine()) != null)\r{\rFoo.CreateFromCsvLine(line);\r// ...\r }\r}\r  \r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  public static Foo CreateFromCsvLine(string line)\r{\rreturn CreateFromFields(ExtractFields(line, 3));\r}\rprivate static string[] ExtractFields(string line, int propertyCount)\r{\rvar result = new string[propertyCount];\rvar index = 0;\rbool isInQuotes = false;\rvar chars = line.ToCharArray();\rStringBuilder str = new StringBuilder(string.Empty); foreach (var t in chars)\r{\rif (t == \u0026#39;\u0026#34;\u0026#39;)\r{\risInQuotes = !isInQuotes;\r}\relse if (t == \u0026#39;,\u0026#39; \u0026amp;\u0026amp; !isInQuotes)\r{\rresult[index++] = str.ToString();\rstr.Clear();\r}\relse\r{\rstr.Append(t);\r}\r} result[index] = str.ToString(); return result;\r}\r  \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"9f48a86848b9a7c8\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r L\u0026rsquo;algorithme d\u0026rsquo;analyse des lignes csv est simple et limitée mais correspond à mon besoin.\nEt voici le résultat :\n   Method Mean %     TextFieldParser 6,617.43 ms 0%   CsvHelper 4,018.37 ms -39 %   TinyCsvParser 1,062.29 ms -84 %   Custom 1,083.97 ms -83 %    Comment TinyCsvParser peut-il encore être plus performant ? Simplement car ce framework utilise le base le parallélisme. Nous allons en faire de même:\nSolution personnalisée avec parallélisme SampleCsvParser\rStreamReaderEnumerator\r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  [Benchmark]\rpublic void CustomParallel()\r{\rusing var streamReader = new StreamReader(_csvFilePath);\rvar enumerator = new StreamReaderEnumerable(streamReader);\rvar po = new ParallelOptions\r{\rMaxDegreeOfParallelism = Environment.ProcessorCount\r};\rvar action = new Action\u0026lt;string\u0026gt;(line =\u0026gt;\r{\rFoo.CreateFromCsvLine(line);\r// ...\r });\rParallel.ForEach(enumerator, po, action);\r}\r  \r\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109  /// \u0026lt;summary\u0026gt;\r/// This method comes from \u0026lt;see href=\u0026#34;!:https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1.etenumerator\u0026#34;\u0026gt;msdn\u0026lt;/see\u0026gt;\r/// \u0026lt;/summary\u0026gt;\rpublic class StreamReaderEnumerable : IEnumerable\u0026lt;string\u0026gt;\r{\rprivate readonly StreamReader _sr;\rpublic StreamReaderEnumerable(StreamReader streamReader)\r{\r_sr = streamReader;\r}\r// Must implement GetEnumerator, which returns a new StreamReaderEnumerator.\r public IEnumerator\u0026lt;string\u0026gt; GetEnumerator()\r{\rreturn new StreamReaderEnumerator(_sr);\r}\r// Must also implement IEnumerable.GetEnumerator, but implement as a private method.\r private IEnumerator GetEnumerator1()\r{\rreturn GetEnumerator();\r}\rIEnumerator IEnumerable.GetEnumerator()\r{\rreturn GetEnumerator1();\r}\r}\r/// \u0026lt;summary\u0026gt;\r/// This method comes from \u0026lt;see href=\u0026#34;!:https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1.etenumerator\u0026#34;\u0026gt;msdn\u0026lt;/see\u0026gt;\r/// \u0026lt;/summary\u0026gt;\rpublic class StreamReaderEnumerator : IEnumerator\u0026lt;string\u0026gt;\r{\rprivate readonly StreamReader _sr;\rpublic StreamReaderEnumerator(StreamReader streamReader)\r{\r_sr = streamReader;\r}\rprivate string _current;\r// Implement the IEnumerator(T).Current publicly, but implement  // IEnumerator.Current, which is also required, privately.\r public string Current\r{\rget\r{\rif (_sr == null || _current == null)\r{\rthrow new InvalidOperationException();\r}\rreturn _current;\r}\r}\rprivate object Current1 =\u0026gt; this.Current;\robject IEnumerator.Current =\u0026gt; Current1;\r// Implement MoveNext and Reset, which are required by IEnumerator.\r public bool MoveNext()\r{\r_current = _sr.ReadLine();\rreturn _current != null;\r}\rpublic void Reset()\r{\r_sr.DiscardBufferedData();\r_sr.BaseStream.Seek(0, SeekOrigin.Begin);\r_current = null;\r}\r// Implement IDisposable, which is also implemented by IEnumerator(T).\r private bool _disposedValue;\rpublic void Dispose()\r{\rDispose(true);\rGC.SuppressFinalize(this);\r}\rprotected virtual void Dispose(bool disposing)\r{\rif (!_disposedValue)\r{\rif (disposing)\r{\r// Dispose of managed resources.\r }\r_current = null;\rif (_sr != null)\r{\r_sr.Close();\r_sr.Dispose();\r}\r}\r_disposedValue = true;\r}\r~StreamReaderEnumerator()\r{\rDispose(false);\r}\r}\r  \r\r\r\r'use strict';\rvar containerId = JSON.parse(\"\\\"5ccaa67cc9d43f8d\\\"\");\rvar containerElem = document.getElementById(containerId);\rvar codetabLinks = null;\rvar codetabContents = null;\rvar ids = [];\rif (containerElem) {\rcodetabLinks = containerElem.querySelectorAll('.codetab__link');\rcodetabContents = containerElem.querySelectorAll('.codetab__content');\r}\rfor (var i = 0; i 0) {\rcodetabContents[0].style.display = 'block';\r}\r    Method Mean %     TextFieldParser 6,617.43 ms 0%   CsvHelper 4,018.37 ms -39 %   TinyCsvParser 1,062.29 ms -84 %   Custom 1,083.97 ms -83 %   CustomParallel 632.97 ms -90 %    Le temps est divisé par 2 par rapport à TinyCsvParser. Au final, sur mon fichier de 30Go je suis passé de 7min à 3min20 de traitement de manière simple.\r Conclusion Les performances d\u0026rsquo;une solution personnalisée laissent rêveur, néanmoins ce code ne répond qu'à un seul et unique cas: les très gros fichiers csv propre et simple.\nMais dans le cas où vous ayez un grand nombre de fichier csv avec des \u0026ldquo;qualités\u0026rdquo; variables, il est fortement recommandé de passer par un framework tel que CsvHelper ou TinyCsvParser où un grand nombre de bons développeurs ont pu analyser les performances de chaque ligne de code permettant de gérer tout les cas.\nNB: Il est intéressant de se rendre compte que le classement est totalement chamboulé sur des petits fichiers csv (exemple avec un csv de 10 lignes):\r   Method Mean %     TextFieldParser 253.18 us 0%   CsvHelper 991.40 us +291 %   TinyCsvParser 653.78 us +158 %   Custom 50.99 us -79 %   CustomParallel 113.25 us -55 %    Ce qui prouve encore qu\u0026rsquo;il n\u0026rsquo;y a pas de magie en développement, que tout dépend du contexte et annexement que le parallélisme peut être un piège.\r Source Documentation  https://docs.microsoft.com/en-us/dotnet/api/microsoft.visualbasic.fileio.textfieldparser https://github.com/JoshClose/CsvHelper https://github.com/bytefish/TinyCsvParser https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.ienumerable-1.getenumerator https://docs.microsoft.com/en-us/dotnet/standard/parallel-programming/potential-pitfalls-in-data-and-task-parallelism  ","description":"","id":7,"section":"posts","tags":["dotnet","csharp","algorithm","performance","benchmark"],"title":"[.NET] Comment lire un très gros fichier csv","uri":"https://blog.jeremylandon.com/fr/2020/03/30/dotnet-comment-lire-un-tres-gros-fichier-csv/"},{"content":"Une des façons les plus simples et courantes d\u0026rsquo;utiliser les services de messagerie tels qu\u0026rsquo;Azure Service Bus est pour effectuer une communication unidirectionnel.\nsource:\rhttps://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messaging-overview\r\r\nExemple: Bob en tant qu\u0026rsquo;envoyeur de message et Eve en tant que réceptionniste.\n1. Eve écoute la file d\u0026rsquo;attente Q1\n2. Bob envoie un message sur Q1\n3. Eve reçoit le message de Bob à partir Q1\nMais comment Bob peut-il savoir que le traitement de Eve est terminé ?\nOu plus généralement comment ces 2 services peuvent-ils communiquer de manière bidirectionnelle? C\u0026rsquo;est là que le pattern Request/Response (ou Request/Reply) intervient.\nLe pattern Request/Response Ce pattern utilise un routage de message afin d\u0026rsquo;obtenir une communication bidirectionnel entre deux services.\nFonctionnellement c\u0026rsquo;est très simple, l\u0026rsquo;envoyeur envoie un message sur une file d\u0026rsquo;attente et attend une réponse sur une autre file d\u0026rsquo;attente.\nsource:\rhttps://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReplyJmsExample.html\r\r\nIl existe 4 types de routage principaux qui sont très bien détaillés ici : https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messages-payloads\nDans la version \u0026ldquo;la plus simple\u0026rdquo; (Request/Response simple), il n\u0026rsquo;existe aucune garantie que Bob reçoit son message de réponse. En effet si un nouvel utilisateur nommé Alice écoute la même file d\u0026rsquo;attente, elle pourrait intercepter le message destiné à Bob.\nConcurrence entre Bob et Alice:\r\r\nNaturellement une idée pourrait venir en tête assez rapidement : Bob créé une file d\u0026rsquo;attente à lui et attend la réponse dessus. Une fois la réponse obtenue il supprime la file d\u0026rsquo;attente.\nC\u0026rsquo;est une bonne logique, mais qui n\u0026rsquo;est pas à faire, car:\n elle implique une gestion des services morts (que faire si le processus crash sans avoir supprimé son service ? Doit-on supprimer le service avec les lettres mortes associées qui fournissent de précisieuses informations pour régler un potentiel bug ?\u0026hellip;) elle n\u0026rsquo;est évidemment pas performante (il faudra à chaque fois créer et supprimer la queue, dans des fréquences parfois élevées) elle introduit une pollution du Service Bus Namespace qui le rend difficile/impossible à analyser  Enfin c\u0026rsquo;est une solution personnalisée, et le standard est toujours à privilégier. N\u0026rsquo;en existe-t-il pas un ?\nJustement si, grace au protocole AMQP qui apporte une notion de groupe, retranscrite chez Microsoft sous le nom session qui résout très simplement et rapidement cette problématique.\nLes sessions (groupe) Pour garantir que Bob soit le seul à récupérer le message de réponse qui lui est destiné, nous allons utiliser les sessions (ou plus précisement les groupes du protocole AMQP), qui pour faire simple apporte une multipléxage et ainsi plusieurs utilisateurs peuvent écouter la même file tout en ayant chacun leur propre groupe de message.\nBob écoute et verrouille une session spécifique sur la file d\u0026rsquo;attente, ainsi lui seul pourra écouter ses messages (à l\u0026rsquo;image d\u0026rsquo;une sous file d\u0026rsquo;attente réservée à Bob).\nBob devra fournir des informations supplémentaires à son message afin que le réceptionneur (Eve) puisse envoyer correctement le message de réponse.\nTechniquement cela se traduit par deux propriétés défini par le protocole AMQP 1.0 :\nle nom des champs du protocole AMQP ne sont pas forcement les mêmes que ceux de l\u0026rsquo;API (ex: group-id dans le protocole = SessionId dans l\u0026rsquo;API)\r  ReplyTo (reply-to): chemin d\u0026rsquo;accès où Bob attend la réponse. Eve y enverra son message de réponse. ReplyToSessionId (reply-to-group-id): l\u0026rsquo;id de la session écoutée par Bob. Eve assignera cette valeur à la propriété SessionId (group-id) de son message de réponse.  Exemple L\u0026rsquo;exemple sera réalisé avec Microsoft.Azure.ServiceBus et de deux file d\u0026rsquo;attente (la logique reste la même avec les rubriques).\nTechniquement il est indispensable que la file d\u0026rsquo;attente de réponse accepte les sessions.\nCela peut se fait via le portail Azure.\nsource:\rhttps://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions\r\r\nOu via le code avec la propriété RequiresSession.\nCreation des files d\u0026rsquo;attente Dans un premier temps nous allons créer pour la démonstration 2 files d\u0026rsquo;attente:\n sample.request: sans session, utilisé pour envoyer les messages de Bob à traiter par Eve. sample.retry: avec session, utilisé pour envoyer la réponse à Bob.  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  static async Task Main()\r{\rvar connectionString = \u0026#34;\u0026lt;your_connection_string\u0026gt;\u0026#34;;\rvar requestQueueName = \u0026#34;sample.request\u0026#34;;\rvar replyQueueName = \u0026#34;sample.reply\u0026#34;;\r// create queues\r await Task.WhenAll(CreateQueueAsync(connectionString, requestQueueName, false), CreateQueueAsync(connectionString, replyQueueName, true));\r}\r// /!\\ IT\u0026#39;S JUST FOR DEMO\rstatic async Task CreateQueueAsync(string connectionString, string queueName, bool requiresSession)\r{\rvar managementClient = new ManagementClient(connectionString);\rif (await managementClient.QueueExistsAsync(queueName))\r{\rawait managementClient.DeleteQueueAsync(queueName);\r}\rawait managementClient.CreateQueueAsync(new QueueDescription(queueName)\r{\rRequiresSession = requiresSession\r});\r}\r  Pour la démonstration chaque service sera simulé par un thread.\nThread de l\u0026rsquo;envoyeur (Bob) Bob envoie un message avec la propriété ReplyTo égal au chemin d\u0026rsquo;accès à la file d\u0026rsquo;attente de réponse et ReplyToSessionId égal à l\u0026rsquo;identifiant sa session.\nUne fois le message envoyé Bob écoute sa session.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  public static class SampleThreadFactory\r{\r...\rpublic static Thread CreateRequestor(string threadId, string connectionString, string requestQueueName, string replyQueueName)\r{\rreturn new Thread(async () =\u0026gt;\r{\r/*** send message ***/\rvar messageSender = new MessageSender(connectionString, requestQueueName);\rvar sessionId = \u0026#34;session-\u0026#34; + threadId;\rvar message = new Message\r{\rMessageId = threadId,\rReplyTo = new ServiceBusConnectionStringBuilder(connectionString) { EntityPath = replyQueueName }.ToString(),\rReplyToSessionId = sessionId,\rTimeToLive = TimeSpan.FromMinutes(2)\r};\rConsole.WriteLine($\u0026#34;{threadId} send a message to \u0026#39;{requestQueueName}\u0026#39; with replyToSessionId=\u0026#39;{message.ReplyToSessionId}\u0026#39; and entityPath=\u0026#39;{replyQueueName}\u0026#39;\\n\u0026#34;);\rawait messageSender.SendAsync(message);\rawait messageSender.CloseAsync();\r/*** send message ***/\r/*** wait response ***/\rSessionClient sessionClient = new SessionClient(connectionString, replyQueueName);\rvar session = await sessionClient.AcceptMessageSessionAsync(sessionId);\rConsole.WriteLine($\u0026#34;{threadId}\u0026#39;s waiting a reply message from \u0026#39;{replyQueueName}\u0026#39; with sessionId=\u0026#39;{sessionId}\u0026#39;...\\n\u0026#34;);\rMessage sessionMessage = await session.ReceiveAsync(TimeSpan.FromMinutes(2));\rConsole.WriteLine($\u0026#34;{threadId} received a reply message from \u0026#39;{replyQueueName}\u0026#39; with sessionId=\u0026#39;{sessionMessage.SessionId} (original: {sessionId})\u0026#39;\\n\u0026#34;);\rawait session.CompleteAsync(sessionMessage.SystemProperties.LockToken);\rawait session.CloseAsync();\rawait sessionClient.CloseAsync();\r/*** wait response ***/\r});\r}\r}\r  Thread du répondeur (Eve) Eve écoute la file d\u0026rsquo;attente sur laquelle Bob envoie ses messages.\nUne fois qu\u0026rsquo;un message est intercepté, elle envoie un message de réponse sur le chemin d\u0026rsquo;accès défini par la propriété ReplyTo.\nLe message envoyé contient la propriété SessionId définie à partir la propriété ReplyToSessionId du message intercepté (et pour le suivi ainsi qu\u0026rsquo;une standardisation, il est fortement recommandé de définir la propriété CorrelationId avec l\u0026rsquo;id du message réceptionné).\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  public static class SampleThreadFactory\r{\rpublic static Thread CreateReplier(string threadId, string connectionString, string requestQueueName)\r{\rreturn new Thread(() =\u0026gt;\r{\rvar messageReceiver = new MessageReceiver(connectionString, requestQueueName);\rmessageReceiver.RegisterMessageHandler(\rasync (message, cancellationToken) =\u0026gt;\r{\rvar connectionStringBuilder = new ServiceBusConnectionStringBuilder(message.ReplyTo);\rvar replyToQueue = new MessageSender(connectionStringBuilder);\rvar replyMessage = new Message(Encoding.UTF8.GetBytes($\u0026#34;processed by {threadId}\u0026#34;))\r{\rCorrelationId = message.MessageId,\rSessionId = message.ReplyToSessionId,\rTimeToLive = TimeSpan.FromMinutes(2)\r};\r/**** Simulate an action *****/\rConsole.WriteLine($\u0026#34;{threadId} works...\\n\u0026#34;);\rawait Task.Delay(new Random().Next(1000, 2000), cancellationToken);\r/*******************************/\rConsole.WriteLine($\u0026#34;{threadId} send a reply message to \u0026#39;{connectionStringBuilder.EntityPath}\u0026#39; with sessionId=\u0026#39;{message.ReplyToSessionId}\u0026#39;\\n\u0026#34;);\rawait replyToQueue.SendAsync(replyMessage);\r}, new MessageHandlerOptions(args =\u0026gt; throw args.Exception)\r{\rMaxConcurrentCalls = 10\r});\r});\r}\r  Initialisation du contexte de test 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  static async Task Main()\r{\rvar connectionString = \u0026#34;\u0026lt;your_connection_string\u0026gt;\u0026#34;;\rvar requestQueueName = \u0026#34;sample.request\u0026#34;;\rvar replyQueueName = \u0026#34;sample.reply\u0026#34;;\r// create queues\r await Task.WhenAll(CreateQueueAsync(connectionString, requestQueueName, false), CreateQueueAsync(connectionString, replyQueueName, true));\r// start all\r Parallel.ForEach(new List\u0026lt;Thread\u0026gt;\r{\rSampleThreadFactory.CreateRequestor(\u0026#34;REQUESTOR-BOB\u0026#34;, connectionString, requestQueueName, replyQueueName),\rSampleThreadFactory.CreateReplier(\u0026#34;REPLIER-EVE\u0026#34;, connectionString, requestQueueName)\r}, (thread, state) =\u0026gt; thread.Start());\rConsole.Read();\r}\r  Résulat Et aucun problème avec plusieurs envoyeur, chacun reçoit le message de réponse qui lui est destiné.\nVoilà!\nSources Repository  https://github.com/Golapadeog/sample-azure-service-bus-request-response  Documentation  https://www.enterpriseintegrationpatterns.com/patterns/messaging/RequestReplyJmsExample.html https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-amqp-request-response https://docs.microsoft.com/en-us/azure/service-bus-messaging/service-bus-messages-payloads https://docs.microsoft.com/en-us/azure/service-bus-messaging/message-sessions https://en.wikipedia.org/wiki/Request%E2%80%93response https://docs.oasis-open.org/amqp/core/v1.0/os/amqp-core-messaging-v1.0-os.html  ","description":"","id":8,"section":"posts","tags":["dotnet","csharp","azure","pattern"],"title":"[Azure] Pattern Request/Response avec Azure Service Bus","uri":"https://blog.jeremylandon.com/fr/2020/03/22/azure-pattern-request-response-avec-azure-service-bus/"},{"content":"Lors d\u0026rsquo;une tentative d\u0026rsquo;un copier/coller (pression longue) sur un champ Text sur IOS le message suivant peut apparaitre :\n The getter \u0026lsquo;pasteButtonLabel\u0026rsquo; was called on null.\nReceiver: null\nTried calling: pasteButtonLabel\r Si tel est le cas, c\u0026rsquo;est qu\u0026rsquo;IOS n\u0026rsquo;arrive tout simplement pas à trouver la localisation adaptée pour les boutons d\u0026rsquo;actions.\nPour corriger ce point il suffit de créer un LocalizationsDelegate personnalisé pour IOS :\n1 2 3 4 5 6 7 8 9 10 11 12  class CupertinoLocalisationsDelegate extends LocalizationsDelegate\u0026lt;CupertinoLocalizations\u0026gt; {\rconst CupertinoLocalisationsDelegate();\r@override\rbool isSupported(Locale locale) =\u0026gt; true;\r@override\rFuture\u0026lt;CupertinoLocalizations\u0026gt; load(Locale locale) =\u0026gt; DefaultCupertinoLocalizations.load(locale);\r@override\rbool shouldReload(CupertinoLocalisationsDelegateold) =\u0026gt; false;\r}\r  Et de l\u0026rsquo;utiliser au niveau de la MaterialApp :\n1 2 3 4 5 6 7  MaterialApp(\r...\rlocalizationsDelegates: const \u0026lt;LocalizationsDelegate\u0026lt;dynamic\u0026gt;\u0026gt;[\rGlobalMaterialLocalizations.delegate,\rGlobalWidgetsLocalizations.delegate,\r+ CupertinoLocalisationsDelegate(),\r ], ...\r  A noter qu\u0026rsquo;avec cette classe la localisation utilisée pour les actions sera celle par défaut du téléphone.\nPour corriger ce point il faut modifier la logique de la méthode load(Local locale) qui permet de définir la localisation.\r ","description":"Exception : The getter \"pasteButtonLabel\" was called on null","id":9,"section":"posts","tags":["flutter","dart","ios","mobile","exception"],"title":"[Flutter] Exception lors d'une copie sous IOS","uri":"https://blog.jeremylandon.com/fr/2019/10/21/flutter-exception-lors-dune-copie-sous-ios/"}]